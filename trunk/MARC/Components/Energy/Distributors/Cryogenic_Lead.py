## @ingroup Components-Energy-Distributors
# Cryogenic_Lead.py
#
# Created:  Feb 2020, K. Hamilton - Through New Zealand Ministry of Business Innovation and Employment Research Contract RTVU2004 
# Modified: Nov 2021, S. Claridge

# ----------------------------------------------------------------------
#  Imports
# ----------------------------------------------------------------------

# MARC imports
import MARC

from MARC.Components.Energy.Energy_Component import Energy_Component
from MARC.Methods.Costs.Correlations.Industrial_Costs.compute_industrial_costs import compute_industrial_costs
from MARC.Methods.Cryogenics.Leads.lead_calculations import Q_min
from MARC.Methods.Cryogenics.Leads.lead_calculations import calc_current
from MARC.Methods.Cryogenics.Leads.lead_calculations import LARatio
from MARC.Attributes.Solids.Solid import Solid
from scipy import integrate
from scipy import interpolate
from scipy.misc import derivative
import numpy as np
# ----------------------------------------------------------------------
#  Cryogenic Lead Class
# ----------------------------------------------------------------------

## @ingroup Components-Energy-Distributors
class Cryogenic_Lead(Energy_Component):
    
    def __defaults__(self):
        """ This sets the default values.
    
            Assumptions:
            Cryogenic Leads only operate at their optimum current, or at zero current.
    
            Source:
            Current Lead Optimization for Cryogenic Operation at Intermediate Temperatures - Broomberg
    
            Inputs:
            None
    
            Outputs:
            None
    
            Properties Used:
            None
            """         
        self.cold_temp                  = 0.0    # [K]
        self.hot_temp                   = 0.0    # [K]
        self.current                    = 0.0    # [A]
        self.length                     = 0.0    # [m]
        self.material                   = None
        self.mass_properties.mass       = 0.0 
    
        self.outputs.cross_section      = 0.0    # [m2]
        self.outputs.optimum_current    = 0.0    # [A]
        self.outputs.minimum_Q          = 0.0    # [W]
        self.outputs.unpowered_Q        = 0.0    # [W]
        self.outputs.Q                  = 0.0    # [W]

        self.inputs.current             = 0.0    # [A]

    def initialize_material_lead(self, conditions):
        """
        Defines an optimum material lead for supplying current to a cryogenic environment given the operating conditions and material properties.
        
        Assumptions:
        None
        
        Inputs:
 
        Outputs:      
            self.outputs     
                mass                [kg]
                cross_section       [m]
                optimum_current     [A]
                minimum_Q           [W]

        Properties Used:
            self.
                cold_temp           [K]
                hot_temp            [K]
                current             [A]
                length              [m]
                material
        """

        # Unpack properties
        cold_temp   = self.cold_temp
        hot_temp    = self.hot_temp 
        current     = self.current  
        length      = self.length   
        material    = self.material
        

        # Find the heat generated by the optimum lead
        minimum_Q = Q_min(material, cold_temp, hot_temp, current)

        # # Calculate the optimum length to cross-sectional area ratio
        la_ratio = LARatio(material, cold_temp, hot_temp, current, minimum_Q)

        # Calculate the cross-sectional area
        cs_area = length/la_ratio
        # Apply the material density to calculate the mass
        mass = cs_area*length*material.density

        # Pack up results
        self.mass_properties.mass           = mass
        self.outputs.cross_section          = cs_area
        self.outputs.optimum_current        = current
        self.outputs.minimum_Q              = minimum_Q

        # find the heat conducted into the cryogenic environment if no current is flowing
        unpowered_Q             = self.Q_unpowered(conditions)

        # Pack up unpowered lead
        self.unpowered_Q        = unpowered_Q[0]

    def Q_unpowered(self, conditions):
        """
        Estimates the heat flow into the cryogenic environment if no current is supplied to the lead.
        
        Assumptions:
        None
        
        Inputs:

        Outputs:      
            self.outputs     
                mass                [kg]
                cross_section       [m]
                optimum_current     [A]
                minimum_Q           [W]

        Properties Used:
            self.
                cold_temp           [K]
                hot_temp            [K]
                current             [A]
                length              [m]
                material

            self.outputs
                cross_section       [m2]
        """

        # unpack properties
        hot_temp        = self.hot_temp     
        cold_temp       = self.cold_temp    
        cross_section   = self.outputs.cross_section
        length          = self.length
        material        = self.material

        # Integrate the thermal conductivity across the relevant temperature range.
        integral = integrate.quad(lambda T: material.thermal_conductivity(T), cold_temp, hot_temp)

        # Apply the conductivity to estimate the heat flow
        Q       = integral[0] * cross_section / length

        # Electrical power is obviously zero if no current is flowing
        power   = 0.0

        self.outputs.Q = Q
        
        return [Q, power]

    def Q_offdesign(self, conditions):
        """
        Estimates the heat flow into the cryogenic environment when a current other than the current the lead was optimised for is flowing. Assumes the temperature difference remains constant.
        
        Assumptions:
        None
        
        Inputs:
            self.inputs
                current     [A]

        Outputs:      
            [lead cooling power, cryogenic loading due to lead] list    [W, W]

        Properties Used:
            self.outputs
                optimum_current     [A]
                minimum_Q           [W]
                unpowered_Q         [W]
                cross_section       [m2]

            self. 
                cold_temp           [K]
                hot_temp            [K]
                length              [m]
                material
        """

        
        current = self.inputs.current
        

        values = [calc_current(self,x) for x in current]
        
    
        return np.array(values)
